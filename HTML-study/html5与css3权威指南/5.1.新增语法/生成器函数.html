<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    /*es2015:新增：生成器函数
    1，生成器函数以 function* 开始
    2，生成器函数内部，yield为关键字，可写多条yield语句
    3，生成器函数可以暂停，利用yield语句将其暂时挂起
    4，生成器函数是非线程的，即代码的执行顺序是连续的，可确定的，不会并发执行*/
    function* sample(name) {
        yield "你好：" + name + "！";
        yield "欢迎来到我的世界！";
        if (name.startsWith("张")) {
            yield "你姓张，那太好了";
        }
        yield "再见！";
    }
    // 调用一个生成器函数，函数不会立即执行
    // 返回一个被暂停的Generator对象（即iter对象）
    // 暂时挂起在函数内部第一行代码之前
    var iter = sample("张雪莹"); // 调用生成器函数
    // 当调用next（）方法时，函数体代码继续执行，直到下一个yield语句之前停止
    // next()的返回值对象：IteratorResult对象，具有value属性和done属性
    // value属性为每一次访问迭代器的返回值，结束后值为undefined
    // done属性：判断对集合的访问是否结束
    console.log(iter.next()); // {value: "你好：张雪莹！", done: false}
    console.log(iter.next()); //
    console.log(iter.next()); //
    console.log(iter.next()); // {value: "再见！", done: false}
    console.log(iter.next()); // {value: undefined, done: true}
    console.log(iter.next()); // {value: undefined, done: true}

    // 例子2
    function* addOne(start, stop) {
        for (var i = start; i <= stop; i++) {
            yield i; // yield语句只能在生成器体内，而不能在匿名函数中
        }
    }
    for (i of addOne(1, 10)) {
        console.log("您已经到达了" + i + "层！");
    }
</script>
</body>
</html>