# es6模块化

1. 设计思想：尽量的静态化，在编译时就能确定模块的依赖关系，以及输入/出的变量（**编译时加载/静态加载**）。
   1. commonJS和AMD模块只能在运行时确定
2. es6模块不是对象，而是通过export命令显式指定输出的代码，然后通过import命令输入。
   1. 编译时加载，可以进行静态分析，比如宏和类型检查
3. 模块：
   1. 一个模块就是一个独立的文件
   2. 文件内部所有变量外部无法获取
   3. 获取模块内部变量，先要使用export输出该变量
4. 模块功能的两个命令：
   1. export：用于规定模块的对外接口
      1. import加载时不可更名的操作（导入形式{})：
         1. 输出单个变量：`export var name = "aig";`
         2. 输出一个变量对象：`export { name as newName, age as newAge };`**（优先考虑：在脚本尾部，更清晰明了）**
         3. 输出函数或类
            1. `export function getAge(){}`
            2. `export class P{}`
      2. import加载可随意更名操作：`export default`命令为模块指定默认输出
         1. 比上述情况多一个default
         2. import命令可以为该匿名函数指定任意名字
            1. `import anyName from xxx`，即不需要使用大括号
            2. 此时export语句可以直接导出函数变量，而不像带有关键字function
               1. `export default foo`，此种情况在上述规则不可用
               2. 本质上是输出一个叫做default的变量，所以后面不需跟变量声明语句，直接带变量名/常量即可
      3. 为输出的变量重命名：使用**as关键字**，如上所示
      4. export规定对外的接口，故而接口名（export语句的变量）必须和模块内部变量建立一一对应关系
      5. export输出的接口与其对应的值是动态绑定关系，可实时获取模块内部的值
         1. commonJS模块输出的是值的缓存，不存在动态更新
      6. export命令必须处于模块顶层作用域的任何位置（不能在块作用域内）
   2. import：用于输入其他模块提供的功能，加载模块
      1. 导入的变量名必须和接口的名称相同
         1. `import { newName, newAge } from 'xxx'`
         2. 重命名使用**as关键字**：`{ newName as latestName }`
      2. import命令导入的变量都是只读的，不能改写，只能改写内部属性（但很难查错，所以输入变量一律只读，不要轻易改变属性）
      3. import中模块文件可使用相对/绝对路径，`.js`后缀可省略
         1. 若导入模块不带路径，应告诉JS引擎模块的位置，此时需要配置文件
      4. import命令有**提升效果**，会自动提升到模块的头部首先执行
         1. 本质：import命令是在编译阶段执行的，在代码运行之前
      5. import是静态执行的（会早于模块内部所有语句先执行）：
         1. 不能在大括号内部将变量进行拼接表示
         2. 不能对引用的路径进行赋值，然后import时使用该赋值变量
         3. 不能在条件/循环中使用
         4. 优点：提高编译器效率
         5. 缺点：无法在运行时加载模块，像条件加载，无法取代**Node require的动态加载**（运行时加载）
         6. 解决方法：引入`import()`函数支持动态加载模块
            1. 参数表示加载模块的位置
            2. 返回一个promise对象
            3. 可用作任何地方，不仅是在模块中
            4. 在运行时加载，即只有代码运行到该处才会加载
            5. import()函数和所加载模块没有静态连接关系，类似Node require
               1. 区别是import()是异步加载，require是同步加载
            6. 适用场景：
               1. 按需加载
               2. 条件加载
               3. 动态模块路径（promise对象）
            7. 注意：
               1. 加载成功后，模块作为对象当作then方法的参数，故而可适用解构赋值获取输出接口，也可直接用参数获取默认接口
               2. 同时加载多个模块，适用`Promise.all`
               3. import()可用作async函数中
      6. import语句会执行加载的模块
         1. `import 'lodash'`仅仅是执行该模块，而不导入任何变量
         2. 多次导入执行上面语句之后执行一次
         3. 若多次导入部分变量，相当于一次导入这些变量
      7. 可全部加载模块变量：使用`*通配符`
         1. `import * as all from xxx`
      8. 结合输出默认接口和其他接口：
         1. `import default, {other1, other2} from xxx`
   3. export和import的复合写法
      1. 若先输入后输出同一个模块：
         1. `export {foo, bar} from xxx`等于`import {foo,bar} from xxx`和`export {foo, bar}`
         2. 此时相当于对外转发该接口，并未导入到当前模块，故不能使用该接口
   4. 模块的继承
      1. 即使用export和import复合写法，然后再加上自己的变量
      2. 此方法不能继承（导入）模块的default方法
   5. 跨模块常量：const常量只在当前模块有效，若要跨模块，必须使用`export const A = 1`的形式
      1. 若使用的常量较多，可专门设立一个constants目录放在常量js文件，然后再将这些常量合并到一个主文件中即可

## import()



## 严格模式

1. es6模块自动采用严格模式，所以需要注意严格模式下的限制条件
   1. 变量需声明后使用
   2. 函数参数不能有同名属性
   3. 不能使用with语句
   4. 不能对只读属性赋值
   5. 不能使用前缀0表示八进制数
   6. 不能删除不可删除属性
   7. 不能删除变量delete prop，只能删除属性delete global[prop]
   8. eval不会在它的外层作用域引入变量
   9. eval和arguments不能被重新赋值
   10. arguments不会自动反应函数参数变化
   11. 不能使用arguments.callee和arguments.caller
   **12. 禁止this指向全局对象**
   13. 不能使用fn.caller和fn.arguments获取函数调用堆栈
   14. 增加了保留字像protected、static、interface

