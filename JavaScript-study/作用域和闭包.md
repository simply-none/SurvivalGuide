# 作用域和闭包

## 编译原理

### JavaScript是一门编译语言

- JavaScript引擎编译步骤类似于传统编译语言
- 在词法/语法分析阶段代码优化

	- 对词法进行静态分析
	- 确定变量/函数位置便于执行时快速查找

- 编译发生在代码执行前几微秒

### 编译语言的代码执行步骤

- 分词/词法分析

	- 程序 -> 词法单元 （数组）
	- var a = 2;

		- var
		- a
		- =
		- 2
		- ;

- 解析/语法分析

	- 词法单元 ->  抽象语法树
	- 抽象语法树（AST)

		- 由元素逐级嵌套所组成的代表程序语法结构的树

	- var a = 2;

		- 顶级节点：variable-declaration

			- 子节点：identifier（值为a)
			- 子节点：assignment-expression

				- 子节点：numeric-literal （值为2）

- 代码生成

	- AST -> 机器指令
	- var a = 2;

		- 创建一个变量a，并分配内存
		- 将值2存储在a中

### 编译过程

- JavaScript引擎

	- 负责整个JavaScript的编译和执行过程

- 编译器

	- 负责语法分析和代码生成
	- 处理：var a = 2;

		- 编译器处理var a，若当前作用域存在a，则忽略声明，否则声明新的变量
		- 为引擎生成运行时所需代码
		- 引擎在作用域中查找变量a
		- 找到就赋值，否则触发referenceerror异常

- 作用域

	- 负责收集维护所有声明的标识符（变量/函数等）组成的查询
	- 确定当前执行的代码对标识符的访问权限

## 作用域

### 定义

- 根据名称查找变量的一套规则

### 作用域链

- 引擎查找变量将逐级往上查找（直到全局作用域）

### 词法作用域

- 定义

	- 定义在词法阶段的作用域
	- 由变量和块作用域所处位置决定
	- 词法分析器处理代码时保持作用域不变

		- 其他情况

	- 词法作用域只查找一级标识符

		- 像a、b、c
		- a.b.c则只到a，之后被对象属性访问规则接管对属性的访问

- 修改词法作用域方法

	- 弱点

		- 性能下降

			- 导致词法分析中判定变量位置无效
			- 所有优化都是无意义的
			- 运行速度变慢

		- 严格模式下无效

	- eval函数

		- 用于执行动态创建的代码
		- 字符串为参数，将字符串内容当作eval函数所处位置的程序
		- 动态插入内容到作用域中
		- 与eval相似的效果

			- 定时器第一个参数可为字符串，解释为匿名函数代码
			- new Function最后一个参数为字符串，解释为函数，并将前面的参数作为它的参数

		- 严格模式下eval有自身作用域，上述无效

	- with关键字

	  with(obj) {
	  	a = 3;
	  	b = 4;
	  	c = 5;
	  }
	  
	  var obj = {
	  	a: 1, 
	  	b: 2,
	  	c: 3
	  }

		- 用于重复引用同一对象的多个属性的快捷方式
		- 无需重复引用对象本身
		- 在with内部进行的声明/隐式赋值会添加到with所处的作用域，其中隐式赋值可能会添加到全局作用域

### 动态作用域

- bash、Perl
- 定义

	- 在运行时动态确定作用域

- JavaScript中this机制和其类似

### 函数作用域

- 定义

	- 函数内的变量在整个函数内部可用

- 作用域隐藏（嵌套函数）

	- 最小授权/暴露原则

		- 只暴露必要内容，其他内容隐藏

	- 规避重名冲突

	  可用模块

	- 缺点

		- 污染全局作用域
		- 必须显式调用外层函数
		- 解决方法

- 立即执行函数表达式（IIFE）

  (function() {
  	// ...
  })();
  
  (function() {
  	// ...
  }());
  
  (function example(param) {		// 形参
  	// ...
  })(value)	// 实参

	- 内容只能在该函数内部访问

- 匿名函数

	- 缺点

		- 栈追踪时无有意义名称，调试困难
		- 只能通过arguments.callee引用
		- 省略了函数名

			- 实际上所有的函数都可以加上函数名

### 块作用域

- 例子

	- with关键字

		- with从对象中创建的作用域仅在with声明中有效

	- try-catch中的catch

		- 声明的变量仅在catch中有效
		- 多个该语句使用相同形参时，某些静态检测工具会发出警告
		- 作为es6之前块作用域替代方案

- let关键字

	- 定义

		- 将变量绑定到所在的任意作用域中，通常为{}内部

	- 隐式块作用域

		- let变量附加在一个存在中的块作用域是隐式块
		- for，if，while等

	- 显示块作用域

	  // 显式块
	  if(param) {
	  	// ...
	  	{
	  		let i = 0;
	  	}
	  }
	  
	  // 隐式块
	  if(param) {
	  	let i = 0;
	  }

		- 代码更加清晰

	- let声明不会在块作用域中提升

- const关键字

	- 常量，修改将发生错误

- 优点

	- 方便垃圾回收，释放不必要的内存
	- for循环，每一次循环都重新绑定（相当于每次循环都创建了一个块作用域）

### 作用域内变量/函数声明提升

- 编译阶段先找到所有声明，然后框在其所在的作用域中
- 所有的声明都会在代码被执行前首先被处理
- 只有声明会被提升，其他逻辑留在原地
- 同一作用域内同时声明相同名字的变量和函数，函数会先被提升（重复的声明会被忽略，后面的var声明忽略掉了）

## 闭包

### 通常函数执行完后函数作用域会被销毁（垃圾回收）

### 闭包会让函数作用域之后还继续存在

### 闭包让函数在词法作用域外可以继续访问定义时的词法作用域

### 方式

- 传入函数
- 返回函数
- 然后将内部函数传递到

### 使用场景（回调函数）

- 定时器
- 事件侦听器
- Ajax请求
- 跨窗口通信
- web works
- 函数模块
- es6模块
- 或其他同/异步的回调
- for循环中使用let可构成闭包
- 立即执行函数

### 条件

- 必须有外部函数，且其最少执行/调用一次
- 外部函数必须返回至少一个内部函数

	- 内部函数才可修改/访问私有状态
	- 外部函数才能在私有作用域形成闭包

### 强大的例子（模块模式）

- 必须返回一个包含内部函数的类型（直接返回函数，返回函数对象等）
- 通过返回的函数/对象间接修改闭包中的私有属性/方法（相当于一个公共API）
- 这种实现和很多模块依赖加载器/管理器类似

### 函数模块与es6模块的对比

- 函数模块

	- 编译器无法识别（不能被静态识别）
	- 运行时才有语义

- es6模块

	- 静态识别
	- 编译器可识别且可检查内容是否正确

## 箭头函数

### 痛点

- 混淆了this绑定规则和词法作用域规则
- 箭头函数是匿名的

### 一个合适的方案

- 普通函数使用bind绑定this

  setTimeout(function() {
  	console.log(this)
  }.bind(this), 100);

## 注意事项

### 表示过时或警告

### 最佳实践

