# this和对象原型

## 注意事项

### 本书中5.2小节是一个重点，通过3个例子说明闭包的部分使用方式

## 函数中可以使用fn.variable的形式访问变量/方法

## this

### 定义

- 在运行时进行绑定，指向调用时的运行环境
- 上下文取决于函数调用条件，和函数声明位置无关

	- 函数调用时，会创建一个执行上下文（包含函数在哪里被调用（调用栈），调用方式，传入的参数信息），this为执行上下文的属性

### 调用位置

- 函数在代码中被调用的位置

### 调用栈

- 到达当前执行位置所调用的所有函数
- 调用位置在当前执行函数上一个调用中
- 可通过浏览器调试工具查看调用位置（栈中的第二个元素）

### 绑定规则

- 默认绑定

	- 无法应用其他规则时的默认规则

		- 严格模式指向undefined（指该函数体内部使用严格模式，而非调用位置处于严格模式）
		- 非严格模式指向全局对象

- 隐式绑定

	- 函数引用有上下文时，会把this绑定到该上下文对象
	- 对象属性引用链只有最后一层的调用位置起作用

	  var a = {
	  	x: 1,
	  	b: {
	  		c: function() {
	  				console.log(this.x);
	  		}
	  	}
	  };
	  
	  a.b.c();		// undefined
	  
	  理解：this指向最后一层调用的对象c，由于c没有属性x，则返回undefined
	  

	- 参数传递函数名是一种隐式绑定
	- 隐式丢失

		- 被隐式绑定的函数会丢失绑定对象，应用到默认绑定
		- 第三方库中调用回调函数的函数会修改this

- 显式绑定

	- 直接绑定指定this的绑定对象（call，apply）

		- 传入原始值作为this，会转为对应的包装对象形式（string -> new String())（装箱）

	- 可能会丢失绑定

		- 情形

			- 绑定的this是null或undefined，或参数为空，使用默认绑定
			- 传入一个特殊的空对象

				- this将被限制在该空对象中
				- 最简单形式Object.create(null)：该对象没有prototype委托，比{}更空

		- 情形

			- 间接引用

				- (p.foo = q.foo)()，使用默认绑定

			- 使用软绑定

				- 创建一个Function原型链的函数，然后判断this，若为空/global，则将this指向默认的对象，否则不修改

		- 解决

			- 通过硬绑定（特殊显式绑定）解决

				- 创建一个新函数，并在新函数内部显式绑定某调用函数，之后使用新函数
				- 使用可重复调用的函数解决（bind）

					- 自定义bind，创建新函数，传入绑定的对象和旧函数，返回函数的显式绑定）
					- bind函数返回硬编码的新函数，把指定的参数设定为this的上下文

				- 缺点

					- 降低函数灵活性，无法通过隐式/显式绑定修改this

			- 通过传入一个可选的上下文参数对象（某些函数或第三方库有）

- new绑定

	- 定义

		- 构造函数，使用new操作符调用的函数

	- new的过程

		- 创建一个全新的对象
		- 新对象执行[[prototype]]连接
		- 新对象绑定到函数调用的this
		- 函数无返回其他对象，会自动返回该新对象

### 优先级

- new绑定
- 显式绑定
- 隐式绑定
- 默认绑定

### this的使用场景

- 全局环境使用this，指向顶层对象window
- 构造函数的this，指向实例对象

### 使用this的好处

- 隐式传递一个对象引用，使API更加简洁复用
- 解决在使用模式越复杂，显示传递上下文对象让代码混乱的问题

### this注意事项

- this不指向它所在函数的词法作用域

	- 作用域对象存在引擎内部，无法通过代码访问

- 函数中的this不指向自身

	- 使用函数名可在函数内部指向自身
	- 匿名函数无法指向自身
	- 可使用arguments.callee引用当前正运行的函数对象（废弃）
	- 使用强制绑定指向函数自身（fn.call(fn, ...args))

- this本质和内存的数据结构有关

  var obj = { a: 5};
  
  JavaScript引擎操作过程：
  	1. 在内存中生成一个对象{ a: 5 }
  	2. 把对象的内存地址赋值给变量obj（变量obj得到的是一个引用）
  	3. 读取obj.a的值，先从obj拿到内存地址，从该地址读取原始对象，返回它的属性a
  
  

	- 避免多层函数嵌套this，此时虽然可用that = this解决（this固定）
	- 避免数组处理方法回调中使用this，指向全局，用this固定解决

	  obj.print = function () {
	    this.times.forEach(function (n) {
	      console.log(this.name);
	    }.bind(this));
	  };

	- 避免在回调函数中使用this

- 绑定this的方法

	- bind
	- call
	- apply

- 只要函数被赋值给另一个变量，this的指向就会改变

  var x = "global";
  
  var obj = {
  	x:	"obj",
  	a: function() {
  		console.log(this.x)
  	}
  }
  
  obj.a();		// obj
  (obj.a)();		// obj
  
  
  (obj.b = obj.a)();		// global
  (a = obj.a)();				// global

	- (obj.a)()：绑定了obj
	- obj.a()：绑定obj
	- (obj.b = obj.a)()：绑定的是全局对象window
	- (a = obj.a)()：全局对象window

- 和其他表达式一起使用时，this执行会改变

	- (obj.foo = obj.foo)()
	- (false || obj.foo)()
	- (1, obj.foo)()

### 箭头函数的this

- 箭头函数中无法使用上述规则
- 根据外层作用域决定this

