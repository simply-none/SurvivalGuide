# Vue基础部分

## 安装

- Vue不支持IE8-版本
  - IE8-无法模拟ES5特性
- 浏览器插件Vue Devtools：审查、调试Vue app
- Vue的引入方式
  - script中引入，将会注册为一个全局变量
  - cdn
    - 制作原型/学习，使用最新版本
    - 生产环境，需明确版本号和构建文件，避免版本间兼容性
  - NPM：npm install vue
- Vue的版本：在npm包的dist/目录，有不同的构建版本
  - 开发版本：包含警告与调试模式，代码未压缩
    - UMD：可通过script标签引入
      - 完整版：包含编译器和运行时版本
        - 编译器：将模板字符串编译为JS渲染函数的代码（模板编译）
      - 运行时版：
        - 运行时：用来创建Vue实例、渲染处理虚拟DOM的代码
        - 当用vue-loader/vueify时，`.vue`文件内部的模板会在构建时预编译为JS
        - 最终打包文件可不需要包含编译器，因为完整版体积比运行时版大30%
        - 使用完整版需在打包工具中配置别名
    - CommonJS：用来配合老的打包工具（browserify、webpack1）
    - ES Module
      - 为打包工具提供的ESM：像webpack2/Rollup，其被设计为可以静态分析
      - 为浏览器提供的ESM：用于在现代浏览器中通过`<script type='module'>`直接导入
  - 生产版本：删除了警告，代码压缩
  - 使用最新源码，需自构建源码：`git clone`, `npm install`, `npm run build`

## 介绍

- Vue：
  - 用于构建用户界面的渐进式框架，
  - 核心库只关注视图层，便于与第三方库/项目整合，
  - 能为复杂的SPA(单页应用)提供驱动
- 声明式渲染：
  - 模板语法：`{{ msg }}`（文本插值）
  - 数据与DOM建立关联（响应式）：修改会使相应内容得到更新


### Vue指令：

- Vue指令都以`v-`开头
- 指令的绑定的属性值是单个表达式（v-for除外）
- 某些指令可以接受一个参数，在指令后以冒号显示。
  - 指令的参数还可以是用方括号括起的JS表达式（**动态参数**）
    - `v-bind:[attributeName]="url"`
    - `v-on:[eventName]="doSomething"`
    - attributeName作为一个动态参数的JS表达式进行求值，参数值以最终结果使用
    - 动态参数预期最终会求出一个字符串，异常情况值为null，该值可以显性地用于移除绑定（并且会移除该属性，但其他非字符串值会触发警告
    - **在动态参数表达式中，不能出现空格和引号**，可用计算属性替代
    - **在DOM中使用模板时，不能使用大写字母命名键名，因为浏览器会将属性名强制转为小写**，触发实例中使用了相应的小写字母才可
      - `v-bind:[someAttr]="value"`中someAttr会转为someattr
- 修饰符
  - 以句点指明的特殊后缀，用于指出一个指令应以特殊方式绑定
    - 例如`.prevent`：阻止默认事件发生
- 指令缩写
  - `v-bind`缩写为`:`：
    - `v-bind:href="url"` => `:href="url"`
  - `v-on`缩写为`@`：
    - `v-on:click="doSomething"` => `@click="doSomething`
- 绑定元素：`v-bind`指令：属性值msg来自Vue实例中的data中的msg属性
  - `v-bind:title="msg"`
  - 当元素属性没有以`v-bind`绑定时，该属性值不会从Vue实例中获取，只有绑定了才行
  - 注意指令和参数之间不能有空格，即v-bind与title之间不能有空格
  - **v-bind指令若作用于布尔属性（例如disabled）时，若属性值对应的data选项对象中的值为`null`,`undefined`,`false`时，该属性则不会包含在该元素上。**
  - **数据绑定：能够将数据绑定到DOM文本（模板插值）、attribute（指令带的属性比如title）、DOM结构（控制结构变化，比如`v-if`指令）**
- 条件：`v-if`指令：属性值seen来自Vue实例data中的seen属性
  - `v-if=seen`
- 循环：`v-for`指令：渲染列表
  - `v-for="todo in todos"`
  - 其中todos来自Vue实例data的属性
- 用户交互指令：`v-on`
  - `v-on:click="sendMsg"`
  - v-on后带事件名，属性值为事件发生调用的方法
  - 属性值来自Vue实例methods的方法
  - 编写的方法只关注逻辑层面，不需要触碰DOM（由Vue处理）
- 双向绑定：`v-model`：实现表单输入和应用状态之间双向绑定
  - `<input v-model="msg">`
  - 表示用户输入的内容会在相应的插值内容msg中变化
- `v-once`指令：执行一次性插值，即之后数据发生改变，插值内容不会发生变化，单指令，没有值
- `v-html`指令：
  - `v-html="rawHtml"`
  - 其中rawHtml为data选项对象的属性
  - 使用该属性，会将rawHtml属性值嵌入到该标签内部并渲染为html
  - 不能使用v-html来复合局部模板，因为Vue不是基于字符串的模板引擎（是render函数？？），但Vue是基于HTML的模板语法，故而？？？


### 组件系统：一种抽象，允许使用小型、独立、可复用的组件构建大型应用。
  - 组件树：界面的结构分解（比如页头，内容区，页脚）
  - 组件模板：需要先注册一个组件才能使用该模板元素
    - 组件注册使用`Vue.component(component-name, {props:[],template:,...})`
    - 其中props中的值相当于一个自定义的元素属性
    - Vue组件类似自定义元素（web组件规范的一部分），vue实现了它
      - web组件规范未被所有浏览器实现，但Vue组件支持IE9+以上版本
      - Vue组件有元素自定义元素不具备的功能：跨组件数据流、自定义事件通信、构建工具集成

## Vue实例

- Vue未完全遵循MVVM模型
- **选项对象**：像data，el等等
  - data：当vue实例被创建时，才将data对象中的所有属性加入到Vue的响应式系统中，属性值发生改变，视图将会产生相应（更新）
    - 如果某些属性不确定是否会加在实例上面，可预先设定一些初始值
    - 而当给某变量使用了`Object.freeze()`会阻止修改该属性，即响应系统无法追踪该变化。
- Vue应用的构造：new Vue根实例、可选的嵌套的可复用的组件树
  - 所有的Vue组件都是Vue实例，且接受相同的选项对象，特有选项对象除外。
- Vue实例的实例属性和方法
  - 都有前缀`$`，（例如`$el`即指el选项对象），便于区分用户属性

### 实例生命周期钩子

- 实例被创建有一系列初始化过程：像设置数据监听、编译模板、将实例挂载到DOM、数据变化更新DOM、运行生命周期钩子函数（可在不同阶段添加用户代码）
  - 例如`created`钩子（created选项对象）表示在实例被创建之后执行的代码
  - 生命周期钩子的this指向调用它的Vue实例
  - 不要再选项属性或回调中使用箭头函数，因为箭头函数没有this（会向上级作用域查找this），经常导致一些错误

### 生命周期

- 图示：![生命周期图示](../../img/Vue-lifecycle.png)

## 模板语法

- Vue.js使用了基于HTML的模板语法，允许开发者声明式地将DOM绑定到底层Vue实例的数据
  - 所有的Vue模板都是合法的html，能被遵循规范的浏览器和HTML解析器解析
  - 底层实现中，Vue将模板编译成虚拟DOM渲染函数
  - 偏爱原生JS，可不用模板，直接写渲染函数，使用可选的JSX语法

### 插值

- 文本插值：使用Mustache语法（双大括号）进行数据绑定
  - `{{ msg }}`
  - 若msg是html代码，会原样输出该代码，而不会渲染为HTML格式，输出HTML格式，需使用`v-html`指令
  - 动态渲染任意的html容易导致XSS攻击，只能对可信内容使用HTML插值，绝对不要使用用户提供的内容插值
  - Mustache语法不能作用于元素属性上，此时应使用`v-bind`指令
- 对于所有的数据绑定，都支持JS表达式（会在所属实例中作为JS被解析），而不只只是简单的值，但不支持语句和块结构
  - 每个绑定只能包含一个JS表达式
  - 模板表达式不应该访问用户定义的全局变量，但可以访问系统全局变量（本来就有的）。

## 计算属性和侦听器

### 计算属性

- 模板内部表达式便利但设计初衷是用于简单运算，在其内部放入太多逻辑会让模板过重且难以维护。
- 对于任何复杂逻辑，应当使用计算属性
  - 像绑定普通属性一样在模板中绑定计算属性（语法相同）
  - 计算属性缓存 vs 方法
    - 在模板表达式中调用方法可以达到相同效果`{{ doSomething() }}`
    - 计算属性基于它们的**响应式依赖**进行缓存，**只有**在相关响应式依赖改变才会重新求值，即其依赖的实例中的某些属性改变它们才会改变，而未发生改变时会立即返回之前的计算结果，不用再次执行函数
    - **有缓存的意义**：避免过多的开销（自己理解的）
  - 计算属性 vs 侦听属性
    - 侦听属性：更通用的方式去观察和响应Vue实例上的数据变动
      - 不要滥用watch
  - 计算属性的setter
    - 默认只有getter，需要时可以提供setter（即get/set函数）
    - 当计算属性数据变动时，setter会被调用，其相应的响应式依赖也会被更新

### 侦听器

- `watch`选项：更通用的响应数据变化的方法，当需要在数据变化时执行异步/开销较大的操作时，最有用
- 除了watch选项之外，可以使用命令式的`vm.$watch`api

## Class和Style绑定

- `v-bind`指令主要是类似于对元素的属性进行绑定，然后赋值给该属性
  - 将`v-bind`指令用于class和style时，Vue做了专门的增强，表达式结果类型除了**字符串**，还可是**对象/数组**

### Class绑定

- 使用**对象语法**：传给一个对象以动态切换class
  - `v-bind:class="{ active: isActive }"`
    - 当isActive值为**真值**，则存在active这个class
    - 真值：除false、0、''、null、undefined、NaN以外的值
    - 可传入多个class属性
    - 该指令可与普通class属性（指没有v-bind指令绑定的）共存，不会覆盖原有的class
    - 绑定的数据对象不必内联到模板中，可以直接传入一个对象变量即可
      - 类似`{ active: isActive }` => `classObject`
      - 该对象变量可为一个data中的变量，也可是一个计算属性
- 使用**数组语法**：传入一个数组给`v-bind:class`
  - `v-bind:class="[activeClass, errorClass]"`
  - 即将数组元素变量的属性值作为class
- 联合使用数组和对象语法：
  - `v-bind:class="[{ active: isActive }, errorClass]`
- 可以绑定自定义组件元素的class，方法同上
  - 在自定义组件中使用class属性时，这些class被添加到该组件的根元素上，不会覆盖原有的class

### 内联样式style绑定

- 使用对象语法：非常像css
  - `v-bind:style="{ color: activeColor, fontSize: fontSize + 'px'}"`
  - CSS属性名可使用驼峰式（camelCase）或短横线分隔（kebab-case，此需用引号括起）命名
  - 直接传入一个样式对象会让模板更清晰
    - `{...}` => `styleObject`
    - 对象可在data中或是一个计算属性
- 使用数组语法：将多个样式对象应用到同一个元素中
  - `v-bind:style="[baseStyles, overridingStyles]"`
  - 当需要添加浏览器引擎前缀的CSS属性时，Vue会自动侦测并添加相应的前缀
  - 可以为style绑定的属性提供一个包含多个值的数组，常用于提供多个带前缀的值
    - `:style="{display: ['-webkit-box', '-ms-flexbox', 'flex'] }"`
    - 这样会渲染最后一个被浏览器支持的值

## 条件渲染

### `v-if`

- `v-if`指令用于条件性渲染一块内容，只会在指令表达式值为真时被渲染，否则不会显示该元素
  - `v-if="awesome"`
  - 配合`v-else`使用添加一个ese块
    - `v-else`，无属性值，表`v-if`的else块
    - `v-else`指令所在元素必须紧跟在`v-if`或`v-else-if`指令元素的后面，否则不起作用
  - `v-else-if`：充当`v-if`的else-if块，可连续使用，类编程语言的用法
    - `v-else-if`指令所在元素必须紧跟在`v-if`或`v-else-if`指令元素后面
  - 在template元素中使用`v-if`渲染分组
    - 这样做可以添加到template元素包含的所有子元素上（成组切换），此时template元素是不可见包裹元素（最终不包括template元素）
- 使用key管理可复用的元素
  - 因为Vue会尽可能高效的渲染元素，通常会复用已有元素而不是从头开始渲染（像已输入的内容不会清除）。
    - 好处：运行更快，可在不同登录方式切换等
    - 当两个模板元素包含的元素相同时，使用条件命令切换，不会清除用户已输入的内容，即元素不会被替换，只是替换掉了元素中的内容而已
  - 如果不想复用某些元素，可给这些元素分别加上不同的key属性即可，此时切换，加入key属性的元素将会重新渲染，但未添加key属性的元素仍会被复用
- 不推荐同时在一个元素中使用v-if和v-for，当两者一起使用时，v-for优先级比v-if高，这意味着若同时使用，v-if将分别重复运行于每个v-for循环中，当想为部分项渲染节点时十分有用
  - 若目的是有条件的跳过循环的执行，可将v-if放在外层元素中（比如template等）

### `v-show`

- `v-show`指令也用于根据条件展示元素的选项，
  - `v-show="ok"`
  - 但带有v-show指令的元素始终会被渲染并保留在DOM中，它只是简单的切换元素css属性display
  - v-show不支持template元素，也不支持v-else

### `v-if` vs `v-show`

- `v-if`是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当的被销毁和重建
  - 它是惰性的：若初始渲染条件为假，不做任何渲染，除非条件变为真
  - 更高的切换开销，运行时条件很少改变使用v-if较好
- `v-show`：不过初始条件如何，元素总被渲染，进行display的切换
  - 更高的初始渲染开销，频繁切换应使用v-show较好

## 列表渲染

### `v-for`

- 用`v-for`指令基于一个数组来渲染一个列表
  - 语法：`v-for="item in items"`
  - items是源数据数组，item是被迭代的数组元素别名
  - 在v-for块内，可以访问所有父作用域的属性（比如父元素的data选项数据）
  - v-for支持一个可选的第二个参数，表示当前项的索引
    - `v-for="(item, index) in items"`
    - 可用of替代in作为分隔符，它更接近JS迭代器语法
      - `v-for="item of items"`
  - 可以用v-for遍历一个对象的属性
    - 在遍历对象时，会按`Object.keys()的结果遍历，但不能保证其结果（顺序）在不同的JS引擎下一致
    - `v-for="value in object"`，其中value表示属性的值
    - 可提供第二个参数作为键名属性
      - `v-for="(value, name) in object"`
      - value表示键值（属性值），name表示键名（属性名）
    - 可提供第三个参数作为索引
      - `v-for="(value, name, index) in object`

### 就地更新和节点跟踪

- vue更新使用v-for渲染的元素列表时，默认使用**就地更新**策略
  - 如果数据项顺序被改变，Vue不会移动DOM元素来匹配数据项的顺序，而是就地更新每个元素，并确保每个索引位置正确渲染
  - 这个默认模式是高效的，但是只适用于不依赖子组件状态或临时DOM状态（像表单输入值）的列表渲染输出
- 为了便于**跟踪每个节点**，从而重用和重排现有元素，需要为每项提供一个唯一key属性（该属性值值唯一即可）
  - 尽量使用v-for时提供key属性，除非遍历的dom十分简单，或想刻意依赖默认行为提升性能
  - key属性是Vue识别节点的一个通用机制，并不仅与v-for关联
  - key属性值应该使用基本类型值

### 数组更新检测

- vue将被侦听的数组变异方法进行了包裹，所以将会**触发视图更新**
  - 变异方法：push、pop、shift、unshift、splice、sort、reverse
  - 变异方法：指会改变调用这些方法的原始数组
    - 非变异方法：filter、concat、slice（不会改变原数组，而是返回一个新数组）
    - Vue为了使DOM元素最大限度重用，不会导致使用了非变异方法丢弃现有DOM并重新渲染列表，用一个含相同元素的数组去替换原来数组是非常高效的操作
- 由于JS的限制，Vue不能检测以下数组的变动：（即发生下列操作时Vue不会发生改动，这是指当页面载入之后再发生下列变化时，再次更改无效（事件点击更改，浏览器控制台更改），应使用替代方法，而在页面载入之前有效，比如写在代码中）
  - 当利用索引直接设置一个数组项时
    - `vm.items[indexOfItem] = newValue`
    - 解决方法：2种，实现和上述一样效果，并在响应式系统内触发状态更新
      - 第一种：
        - `Vue.set(vm.items, indexOfItem, newValue)`使用`Vue.set`
      - 第二种：
        - `vm.items.splice(indexOfItem, 1, newValue)`使用`Array.prototype.splice`
      - 第三种：该方法是`Vue.set`的一个别名
        - `vm.$set(vm.items, indexOfItem, newValue)`
  - 当修改数组长度时
    - `vm.items.length = newLength`
    - 解决方法：使用splice
      - `vm.items.splice(newLength)`

### 对象更新检测

- 由于JS限制，Vue不能检测对象属性的添加和删除
  - 对于已经创建的实例，Vue不允许动态添加根级别的响应式属性，
    - 解决方法：
      - 使用`Vue.set(obj, propertyName, value)`添加响应式属性
      - 使用`vm.$set(obj, propertyName, value)`
      - 添加多个对象响应式属性，不能如下列所示：
        - `Object.assign(obj, {prop1: n1, prop2: n2 })`
        - 解决方法：即用两个对象的属性创建一个新的对象
          - 使用`obj = Object.assign({}, obj, {prop1: n1, prop2: n2 })`

### 其他

- 在显示一个数组经过排序/过滤的版本，但不改变/重置原始数据，可创建一个计算属性/函数返回过滤/排序后的版本（相当于不直接对原始数据进行操作，而定义一个新的变量/方法去操作原始数据一样）
- `v-for`中可以接受整数的遍历，即将模板重复对应次数
  - `v-for="n in 10"`
- 可以在template元素上使用v-for指令渲染包含多个元素的内容
- 可以在任何自定义组件中使用v-for指令
  - 在组件中使用v-for时，必需有key属性
  - 任何数据不会被自动传递到组件里，因组件有自己独立的作用域，为了把数据传入到组件，需要使用props属性
    - 数据注入到组件会使组件与指令的运作紧密耦合，不利于组件重复使用
    - 使用**is属性**是十分必要的，因为在某些特殊元素中，只有相应的元素才会当作其内部有效内容，这样做与直接使用<custom-component>相同，但可以避免一些潜在的浏览器解析错误

## 事件处理

- 使用`v-on`指令监听DOM事件，并在触发时运行一些JS代码
  - 当事件处理逻辑变复杂时，直接在v-on中书写大量的js代码不可行，此时应接受一个需要调用的方法名称更好（绑定一个方法名）
  - 或在内联JS语句中调用方法，例如`v-on:click="say('hi')"`
  - 若想在内联语句中访问原始的DOM事件（比如事件对象），可以将**特殊变量$event**传入内联语句中调用方法，例如`v-on:click="warn("msg", $event)"`，此时可以访问event事件对象了

### 事件修饰符

- 事件修饰符在v-on指令中使用，由点开头的指令后缀
  - `.stop`：阻止事件继续传播
  - `.prevent`：阻止事件的默认操作
  - `.capture`：事件捕获，内部元素触发的事件先在该元素上处理，然后才交给内部元素处理
  - `.self`：只有event.target是当前元素自身时触发处理函数
  - `.once`：事件之后触发一次，其他修饰符只能作用于原生DOM事件，而`.once`还能作用到自定义的组件事件上
  - `.passive`：不想阻止事件的默认行为，默认行为（比如滚动事件的滚动行为）将会比调用的事件先触发，尤其能够提升移动端性能
    - 当.passive和.prevent一起使用时，.prevent将会被忽略，并会有一个警告
- **事件修饰符可以串联，其他修饰符也可串联使用**
- 使用修饰符时，顺序很重要，相应的代码会以同样的顺序产生
  - 例如`v-on:click.prevent.self`会阻止所有点击事件，而`v-on:click.self.prevent`只会阻止该元素的点击事件（这应该看修饰符作用的位置，前一个作用在click上，而后一个作用在self上

### 按键修饰符

- Vue允许为v-on在监听键盘事件时添加按键修饰符
  - 比如`.enter`，**可以将KeyboardEvent.key暴露的任意有效按键名转为短横线命名作为修饰符**
  - alt，arrow-right，page-down等
- keyCode事件用法已经废弃可能不会在新的浏览器支持
  - 同样可使用keyCode码作为按键修饰符，比如`v-on:keyup.13="submit"`
  - 为了在必要情况下支持旧浏览器，Vue提供了绝大多数常用按键码的别名（按键修饰符），有些按键在IE9中有不同的key值，支持IE9应首先Vue内置的别名
  - **可通过全局`config.keyCodes`对象自定义按键修饰符别名？？？**
    - `Vue.config.keyCodes.f1 = 112`

### 系统修饰键

- 使用修饰符实现仅在按下相应按键时才触发鼠标或键盘事件的侦听器
  - `.ctrl`：
  - `.alt`：
  - `.shift`：
  - `.meta`：在mac系统meta代表command命令，在Windows系统代表win徽标键
  - 应注意每个修饰键的含义，比如keyup事件和ctrl修饰符使用时，表示事件触发时ctrl必须处于按下状态（即只有在按住该键并释放其他键才能触发keyup.ctrl，而若想在释放ctrl时触发事件应该使用keycode，替换为keyup.17即可
  - `.exact`：精确控制某些键触发事件，上面的修饰符是笼统的，只有满足条件即可，而这是严格满足条件（只有这些修饰符操作时才能触发事件）
  - 鼠标按钮修饰符：会限制处理函数仅响应特定的鼠标按钮
    - `.left`：
    - `.right`
    - `.middle`

### 为什么在HTML中监听事件

- 这种事件监听的方式违背了关注点分离的优良传统，但由于所有的Vue事件处理方法和表达式严格绑定在当前视图的ViewModel上，不会导致维护上的困难
- 使用v-on的好处：
  - 看html模板便能轻松定位在JS代码中相应的方法
  - 无需在JS中手动绑定事件，ViewModel代码可以是非常纯粹的逻辑，和DOM完全解耦，更易于测试
  - 当一个ViewModel被销毁时，所有事件处理器都会自动被删除，无需担心清理

## 表单输入绑定

### 基础用法

- `v-model`指令：用于在表单的<input>、<textarea>和<select>元素上创建双向数据绑定，它会根据控件类型自动选取正确的方法来更新元素
  - `v-model`本质上是语法糖
  - 负责监听用户的输入事件以更新数据
  - `v-model`会忽略所有表单元素的value（针对input文本）、checked（针对单/多选）、selected（针对select）属性的初始值（即会用v-model绑定的内容代替），而总是将Vue实例的数据作为数据来源，应通过JS在组件的data选项中声明初始值
    - 在文本区域textarea元素内部插值并不会生效，应用v-model代替
- `v-model`在内部为不同的输入元素使用不同的属性并抛出不同的事件
  - text和textarea元素使用value属性和input事件
  - checkbox和radio使用checked属性和change事件
  - select字段将value作为prop并将change作为事件
    - 当v-model表达式初始值未能匹配任何选项，select元素将渲染为未选中状态，而在ios中会使用户无法选择第一个选项（该情况不会触发change事件），故推荐提供第一个值为空的禁用选项（value为空，并设置了disabled属性）
    - select元素选中的是option元素的value值（有value值的情况下），为不是内部插入的文本值
    - 单选/复选按钮也是选中的value值
  - 对于需要使用输入法（中文、日语）等语言，v-model不会在输入法组合文字过程中得到更新，若想使用这个效果，应使用input事件

### 值绑定

- 对于单选/复选按钮以及选中框，v-model绑定的值通常为静态字符串（即指选中项value的值），而当复选框v-model绑定的变量是布尔值，则所有的元素同时变为true/false
- 但若想把值绑定到Vue实例的一个动态属性上，可用v-bind实现，且该值可以不是字符串
  - 因为最终v-model绑定的变量值即等于value的值

### 修饰符

- `.lazy`：v-model在每次input事件触发后将输入框的值与数据进行同步（除需用输入法组合的字），可添加lazy修饰符，从而转变为使用change事件进行同步（即在改变时更新，而非输入时更新，需要失去焦点或按住其他特殊按键才会更新）
- `.number`：若想自动将用户输入的值转为数值类型，可给v-model添加number修饰符，这是很有用的，因为即使在type=number时输入元素也总是返回字符串。
  - 若该值无法被parseFloat()解析，则会返回原始的值
  - 失去焦点时才会发生变化
- `.trim`：若要自动过滤用户输入的首尾空白字符，可给v-model添加trim修饰符

- number和trim修饰符都是在失去焦点时，其输入框中的内容会自动变化为相应状态

### 在组件上使用v-model

- HTML原生的输入元素类型并不总能满足需求，但Vue组件系统允许创建具有自定义行为且可复用的输入组件，这些组件可以与v-model一起使用

## 疑问

- 什么是渐进式框架
- 响应式
- 什么叫做逻辑层面
- MVVM模型是什么
- Vue的生命周期
- Vue不是基于字符串的模板引擎，Vue用的是什么模板语法呢？？
- XSS攻击？？
- 什么叫重新渲染，什么叫渲染？？？重新加载还是（事实上重新渲染会将原有内容清空）
- 当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“**就地更新**”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染
- 什么叫视图更新？