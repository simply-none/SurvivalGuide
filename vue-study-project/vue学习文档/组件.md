# 组件

## 组件基础

- 创建一个新组件使用`Vue.component`函数
  - `Vue.component('component-name', {data, template...})`
  - 因为组件是可复用的Vue实例，故与new Vue接收相同的参数，像data、computed、watch、methods以及生命周期钩子等（除某些特有选项el等）
  - 每使用一次组件，就会有一个它的新实例被创建
  - 组件的data选项必须是一个函数，这样每个实例可以维护一份被返回对象独立的拷贝
    - 若不这样，对某个组件进行操作，使用相同组件的其他内容也会受到相同影响

### 组件的组织结构
- 为了能在模板中使用，这些组件必须先注册以便Vue能够识别
- 组件的两种注册类型：
  - 全局注册：通过`Vue.component`方法
    - 全局注册的组件可以用作被注册之后的任何新创建的Vue根实例（new Vue）和其组件树中所有子组件的模板中
  - 局部注册：

### 通过prop向子组件传递数据

- prop：可以在组件上注册一些自定义的属性，当一个值传给prop属性时，它就变成了哪个组件实例的一个属性，这是能够在组件实例（像在模板选项）中访问这个值
  - props选项：一个数组，一个组件默认可拥有任意数量的prop，任何值都可以传递给任何prop

### 单个根元素

- 每个组件必须只有一个根元素，可将这些内容包裹在一个父元素中
- 当组件内容变得越来越复杂时，为每个相关的信息定义一个prop会变得更麻烦，这时应让它接受一个单独的prop选项（此时为该选项添加属性自动可在组件中使用）
- JS的模板字符串（以反引号括起的字符串）可让多行的模板（template选项）更易读，但它们在IE中未被支持（需使用折行转义字符取代：在每行结尾用一个`\`结尾）

### 监听子组件事件

- 组件的某些功能可能需要和父组件进行沟通
  - **父/子组件可能指嵌套层级（html元素嵌套关系，我猜的）**
- 父级组件通过`v-on`监听子组件实例的自定义事件就像处理原生DOM事件一样，父级组件通过监听器接受该事件并触发处理函数
  - 子组件通过调用内建的`$emit`方法传入事件名触发事件
  - 父：监听器`v-on:enlarge-text="postFontSize += 0.1"`
  - 子：`v-on:click="$emit('enlarge-text')"`
- 使用事件抛出一个特定的值很有用，此时可使用`$emit`函数的第二个参数提供这个值
  - 父：`v-on:enlarge-text="postFontSize += $event"`
    - 可通过`$event`访问到被抛出的这个值
    - 若enlarge-text传入的是一个函数，`$event`访问的这个值就是函数的第一个参数
  - 子：`v-on:click=$emit('enlarge-text', 0.1)"`

### 在组件上使用`v-model`

- 自定义事件可用于创建支持v-model的自定义输入组件
  - `v-model="searchText"`
  - 等价于`v-bind:value="searchText" v-on:input="searchText = $event.target.value"`
  - 用在组件上时`v-bind:value="searchText" v-on:input="searchText = $event"`
    - 为了让组件正常工作，组件内的input元素必须
      - 将其value属性绑定到一个叫value的prop上
      - 在其input事件被触发时，将新的值通过自定义的input事件抛出

### 通过插槽分发内容

- Vue自定义的元素**slot**可以将内容加到组件内部，这时只要在需要的地方加入插槽即可（插槽元素加入到template选项内，并不要嵌入值，这时就可在组件内部嵌入值了

### 动态组件

- 组件间的动态切换可通过Vue的`component元素`加一个特殊的is属性实现
  - `<component v-bind:is="currentTabComponent">`
  - currentTabComponent可包括已注册组件的名字或一个组件的选项对象
  - is属性可用于常规HTML元素，但这些元素会视为组件，意味着所有属性将作为DOM属性被绑定，若想某些属性符合预期，需要使用`.prop`修饰器

### 解析模板时的注意事项

- 有些元素内部嵌入的元素是有限制的，而某些元素只能出现在某些元素内部，此时若使用自定义组件在某些有限制元素内部，可能该组件会被作为无效内容提升到外部并导致最终渲染结果出错
  - 解决办法：**使用is特性**
    - 即`<tr is="component-name">`
- 当从以下来源使用模板时限制不存在：
  - 字符串（template选项中）
  - 单文件组件（.vue文件）
  - `<script type="text/x-template">`

## 组件注册

### 组件名

- 组件名：当直接在DOM使用一个组件（非字符串模板/单文件组件），推荐遵循W3C规范（字母小写且包含一个连字符），以避免和HTML元素冲突
- 定义组件名的2种方式：
  - 使用kebab-case：引用该组件时也应使用kebab-case
  - 使用PascalCase：引用该组件时两种命名法都可使用（但直接在DOM中使用只有kebab-case有效）

### 组件注册

- 全局注册：通过`Vue.component`创建的，在注册之后可用在任何新创建的Vue根实例（new Vue）中，而全局组件在各自内部也可互相使用全局组件（即在根实例内部任何地方都可使用）
  - 弊端：全局注册组件即使不再使用，仍然会被包含在最终的构建结果中，使得用户要下载更多的JS代码
- 局部注册：通过普通的JS对象来定义组件，然后在根实例components选项（一个对象）中加入想要使用的组件
  - `var ComponentA = { /* ... */ }`即选项对象
  - components选项：`{'component-a': ComponentA }`，其中属性名是组件的名字，而属性值就是该组件的选项对象
  - 通过局部注册的组件在其子组件中不可用，即2个局部组件不能直接嵌套使用，应该：
    - `var ComponentB = {components: {'component-a': ComponentA }}`
    - 即componentA在componentB中可用
  - 通过Babel和webpack使用es6模块，应使用import/export语法处理组件
    - `export default { components: { ComponentA }}`
    - ComponentA同时是组件的名称和组件选项的变量名

### 模块系统

- 在模块系统中局部注册：推荐创建一个components目录，将每个组件文件放在它的内部
  - 局部注册前应该导入需要使用的组件（使用import...from...语法）
  - 导入的组件可不包含后缀名
- 基础组件的自动化全局注册：
  - 基础组件：相对通用（频繁使用）的组件
  - 使用webpack，可使用`require.context`只全局注册这些非常通用的基础组件，而不必在每个组件注册时导入一系列基础组件列表
  - 全局注册必须在根实例创建之前发生

## Prop

- prop的大小写：由于html的属性名大小写不敏感（浏览器会将大写转为小写）
  - 当使用DOM模板时，camelCase命名的prop需要使用等价的kebab-case命名
  - 但若使用字符串模板，则不存在这个限制
- props类型：
  - 使用**数组**列出prop
  - 若需指定prop值的类型，需以**对象**列出，属性名指prop名，属性值指prop的类型
    - 当遇到错误类型时会从浏览器的JS console中提示用户

### 传递静态或动态的prop

- 可以传一个静态值给prop（不使用变量）`title="my title"`
- 可通过v-bind动态赋值:`v-bind:title="post.title"`
  - 任何类型都可以传值给prop
  - **记住后面用引号括起来的值是一个JS表达式（不是一个字符串）**
  - 传一个数字：
    - 静态：`v-bind:age="24"`
    - 动态：`v-bind:age="post.age`使用变量
  - 传一个布尔值
    - 当一个属性没值时，意味着属性值为true
    - 即使false是静态的，仍需要用引号引起`v-bind:is-published="false"`
    - 动态：`v-bind:is-published="post.isPublished"`
  - 传一个数组：
    - 静态：`v-bind:comment-ids="[1, 2, 3]"`
    - 动态：`v-bind:comment-ids="post.commentIds"`
  - 传一个对象：
    - 静态：`v-bind:author="{name: 'aig', age: 21}"`
    - 动态：`v-bind:author="post.author"`
  - 传一个对象的所有属性：使用不带参数的v-bind
    - `v-bind="post"` <=> `v-bind:id="post.id" v-bind:title="post.title"`

### 单向数据流

- 所有的prop都使得其父子prop之间形成了**单向下行绑定**：父级prop的更新会向下流动到子组件中（反过来不行，防止子组件意外改变父组件状态，会让你的数据流向难以理解）
  - 父级组件更新，子组件所有的prop都会刷新（意味着不应该在子组件内部改变prop，会发出警告）
- 常见的改变prop的情形：
  - 用来传递初始值，子组件希望将该prop作为一个本地的prop数据使用
  - 用来定义一个计算属性，即传入prop值但不改变它，而是定义一个新的变量来改变他
    - 注意JS中对象和数组是通过引用传入的

### prop验证

- 为组件的prop指定验证要求，即为props的值提供一个带有验证需求的**对象**（props是对象，然后**属性名为单个prop，属性值为prop类型或者一个对象**
- prop属性值的类型：
  - 数据类型字符串/数组：`propA: Number`, 或`propB: [String, Number]`
  - 对象：
    - 例如`propA: {type: String, required: true, default: "abc"}
    - 带有默认值的对象：`propA: {type: Object, default: function(){return {message: "hello"}}}`其中对象/数组默认值必须从一个工厂函数中获取
- props会在组件实例创建之前进行验证，当props验证失败时，实例的属性在default/validator函数中是不可用的
- 类型检查`type`
  - 类型：String、Number、Boolean、Array、Object、Date、Function、Symbol
  - type可以是自定义的构造函数（自定义类型），并且通过instanceof进行检查确认
  - 注意null和undefined会通过任何类型的验证

### 非prop的属性

- 非prop属性：指传向一个组件但该组件并没有相应prop定义的属性
  - 组件可以接受任意的属性，这些属性会被添加到组件的根元素上
- 对于绝大多数属性来说，从外部提供给组件的值会替换掉组件内部设置好的值，但是class和style属性会将组件模板内的值（template选项中的）与组件父级传入的（自定义元素）值合并
- 禁用属性继承：若不希望组件的根元素继承属性，可在组件的选项对象中设置`inheritAttrs: false`，并配合实例的`$attrs`属性（包含了传递给组件的属性名-值对）使用。
  - 使用上述2个设置之后，可手动决定属性被赋予的元素，在撰写基础组件会经常用到
  - 禁用属性不会影响style/class的绑定


## 自定义事件

### 事件名

- 和组件/prop不同的是：
  - 事件名不存在任何自动化的大小写转换，触发的事件名需要完全匹配监听这个事件所用的名称，即触发camelCase，使用kebab-case无效
  - 事件名不会用作一个JS变量名/属性名，所以没理由去使用camelCase/PascalCase，v-on事件监听器在DOM模板中会自动转换为全小写（html的原因），**推荐使用kebab-case事件名**

### 自定义组件的`v-model`

- 组件上的`v-model`默认会利用名为value的prop和名为input的事件，但类输入控件（单选/多选框等）会将value属性用于不同的目的，model选项可避免这些冲突
  - model选项内部可指定不同于value/input的属性，比如指定prop为checked，指定event为change

### 将原生事件绑定到组件

- 在组件根元素监听一个原生事件，可使用v-on的`.native`修饰符，但是必须保证组件根元素会响应该事件（比如input会相应focus事件，但label不会）
  - 当对不响应事件的组件绑定该事件，该监听器会静默失败，不被调用
- 解决方法：
  - 使用`listeners`选项，配合`v-on="$listeners"`可将所有的事件监听器指向该组件的某个子元素
  - listeners选项对象包含作用在这个组件的所有监听器（事件）
- ***这节代码未搞懂***

### `.sync`修饰符

- 真正的双向绑定会带来维护上的问题（子组件可修改父组件，父组件和子组件无明显的改动来源
  - 推荐用**update:myPropName`模式触发事件来代替
  - 该模式的缩写是一个`.sync`修饰符，带有该修饰符的v-bind不能和表达式一起使用（无效），此时只能提供想要绑定的属性名/对象（绑定多个属性，此时会把该对象每个属性作为独立的prop传进去，然后各自添加用于更新的v-on监听器）
    - 该对象只能是对象变量，不能直接添加对象的字面量形式

## 插槽

### 插槽内容

- 在组件模板中使用slot元素，当使用该组件（自定义元素）时，slot元素将被替换为组件间的内容（比如文本/html代码/组件）
- 若组件模板未包含slot元素，则组件间的内容将会被抛弃

### 编译作用域

- 插槽和模板内部其他地方一样可访问相同的实例属性（相同作用域），但不能访问模板元素的作用域，即模板元素的属性是访问不到的
  - **父级模板里的所有内容是在父级作用域编译的，子模版的所有内容是在子作用域编译的**

### 后备（默认）内容

- 设置插槽的默认内容是有用的，会在没有提供内容（组件内部无内容）的时候被渲染
  - 而当在组件间提供了内容之后，提供的内容会取代默认内容

### 具名插槽

- 当在一个**模板组件**中使用多个插槽时，可利用slot元素的name属性定义额外的插槽，而不带name属性的slot元素带有隐含的名字default
- 在向具名插槽**提供内容**时，可在一个template元素上使用v-slot指令，以v-slot指令参数的形式提供插槽名称，而任何没被包裹在带有v-slot的template元素的内容被视为默认插槽的内容（v-slot:default)
  - 其中v-slot指令参数值是模板中slot元素的name值
  - v-slot指令只能添加到template元素上
    - 特殊情况：当只有一个默认插槽时，可用在组件元素上

- 具名插槽的缩写：
  - v-slot指令的缩写即将参数之前的所有内容替换为字符`#`，`v-slot:header` => `#header`
  - 和其他缩写一样，只有在该指令有参数（明确插槽名）的时候才可用的


### 作用域插槽


- 为了让插槽内容（即组件之间的内容，属于父级作用域）访问组件（局部组件或自定义元素）中的数据，可以将要访问的数据绑定在组件模板的slot元素上，绑定在slot元素上的属性称为插槽prop
  - 此时指定v-slot参数对应slot元素的name
  - 指定v-slot值，以该值作为访问组件数据的引用变量对象，然后组件其他数据为它的属性
- 当只有默认插槽时，组件元素可当作插槽模板使用，即可将v-slot指令用在组件上，此时可省略v-slot指令的参数default
- 默认插槽缩写语法（上述）不能和具名插槽一起使用，此时可能发生作用域不明确（v-slot指令的值作用域为该插槽实例）会发出警告
  - 出现多个插槽，应使用完整的template语法
- 内部工作原理：将插槽内容包括在一个传入单个参数（该参数可访问子组件数据的变量）的函数里
  - 即v-slot的值可以是任何能作为函数定义中的参数的JS表达式，在支持的环境中（单文件组件/浏览器）可使用ES6解构传入具体的插槽prop（比如对象）
  - 这种方法可使模板更简洁，并且可为prop重命名、定义默认内容等

### 动态插槽名

- 动态指令参数可用作v-slot上，以定义动态插槽名，例如`v-slot:[dynamicSlotName]>`

### 其他用法

- 插槽prop允许将插槽转换为可复用的模板，这些模板可以基于输入的prop渲染出不同的内容，这在设计封装数据逻辑同时允许父级组件**自定义部分布局**的可复用组件时最有用
- 想了解更多现实生活中的作用域插槽的用法，我们推荐浏览诸如 Vue Virtual Scroller、Vue Promised 和 Portal Vue 等库。

## 动态组件和异步组件

### 动态组件

- component元素绑定is属性来切换不同的组件
  - `<component v-bind:is="currentTabComponent">`
  - 其中currentTabComponent是绑定的数据（例如data中的数据，表示当前组件的名称）
  - 当切换不同的组件时，Vue会创建一个新的currentTabComponent实例（重新渲染）
  - 若要缓存第一次被创建的内容（切换组件保持原来组件不发生变化），可使用keep-alive元素将component元素包裹起来
  - keep-alive元素要求被切换的组件有自己的名字，不管是通过name选项/局部/全局注册的

### 异步组件（未搞懂）

- 用工厂函数定义一个异步组件（组件的选项对象），工厂函数会异步解析组件的定义
  - 只有在组件需要被渲染时才会触发工厂函数并缓存结果
- 推荐将异步组件和webpack的codesplitting功能（require）一起配个使用
- 可结合webpack和es6在工厂函数中返回一个promise对象
- 局部注册可直接提供一个返回promise的函数
- 在vue router路由中使用上述语法，版本在Vue Router+2.4

## 处理边界情况



## 疑问

- 动态组件切换？？
- 基础组件的自动化全局注册代码没看懂
- props对象的书写方式？？
- 实例的$attrs属性的用法，及禁用属性继承