# Vue 基础部分

> 参考文献
> https://juejin.im/post/5f0dab7df265da22cc286e70

## 安装

- Vue 不支持 IE8-版本
  - IE8-无法模拟 ES5 特性
- 浏览器插件 Vue Devtools：审查、调试 Vue app
- Vue 的引入方式
  - script 中引入，将会注册为一个全局变量
  - cdn
    - 制作原型/学习，使用最新版本
    - 生产环境，需明确版本号和构建文件，避免版本间兼容性
  - NPM：npm install vue
- Vue 的版本：在 npm 包的 dist/目录，有不同的构建版本
  - 开发版本：包含警告与调试模式，代码未压缩
    - UMD：可通过 script 标签引入
      - 完整版：包含编译器和运行时版本
        - 编译器：将模板字符串编译为 JS 渲染函数的代码（模板编译）
      - 运行时版：
        - 运行时：用来创建 Vue 实例、渲染处理虚拟 DOM 的代码
        - 当用 vue-loader/vueify 时，`.vue`文件内部的模板会在构建时预编译为 JS
        - 最终打包文件可不需要包含编译器，因为完整版体积比运行时版大 30%
        - 使用完整版需在打包工具中配置别名
    - CommonJS：用来配合老的打包工具（browserify、webpack1）
    - ES Module
      - 为打包工具提供的 ESM：像 webpack2/Rollup，其被设计为可以静态分析
      - 为浏览器提供的 ESM：用于在现代浏览器中通过`<script type='module'>`直接导入
  - 生产版本：删除了警告，代码压缩
  - 使用最新源码，需自构建源码：`git clone`, `npm install`, `npm run build`

## 介绍

- Vue：
  - 用于构建用户界面的渐进式框架，
  - 核心库只关注视图层，便于与第三方库/项目整合，
  - 能为复杂的 SPA(单页应用)提供驱动
- 声明式渲染：
  - 模板语法：`{{ msg }}`（文本插值）
  - 数据与 DOM 建立关联（响应式）：修改会使相应内容得到更新

### vue 的优点

1. 轻量级框架：只关注视图层，体积小
2. 简单易学：国人开发，易于理解学习
3. 双向数据绑定：操作数据简单
4. 组件化：实现html的封装和利用，在构建SPA有独特的优势
5. 视图、数据、结构分离：使数据更改更简单，不需要进行逻辑代码的修改，只需要操作数据
6. 虚拟DOM：由于dom操作十分耗费性能，虚拟DOM解放了DOM操作，同时比react的虚拟DOM性能更优，运行速度更快

### Vue 指令：

- Vue 指令都以`v-`开头
- 指令的绑定的属性值是单个表达式（v-for 除外）
- 某些指令可以接受一个参数，在指令后以冒号显示。
  - 指令的参数还可以是用方括号括起的 JS 表达式（**动态参数**）
    - `v-bind:[attributeName]="url"`
    - `v-on:[eventName]="doSomething"`
    - attributeName 作为一个动态参数的 JS 表达式进行求值，参数值以最终结果使用
    - 动态参数预期最终会求出一个字符串，异常情况值为 null，该值可以显性地用于移除绑定（并且会移除该属性，但其他非字符串值会触发警告
    - **在动态参数表达式中，不能出现空格和引号**，可用计算属性替代
    - **在 DOM 中使用模板时，不能使用大写字母命名键名，因为浏览器会将属性名强制转为小写**，触发实例中使用了相应的小写字母才可
      - `v-bind:[someAttr]="value"`中 someAttr 会转为 someattr
- 修饰符
  - 以句点指明的特殊后缀，用于指出一个指令应以特殊方式绑定
    - 例如`.prevent`：阻止默认事件发生
- 指令缩写
  - `v-bind`缩写为`:`：
    - `v-bind:href="url"` => `:href="url"`
  - `v-on`缩写为`@`：
    - `v-on:click="doSomething"` => `@click="doSomething`
- 绑定元素：`v-bind`指令：属性值 msg 来自 Vue 实例中的 data 中的 msg 属性
  - `v-bind:title="msg"`
  - 当元素属性没有以`v-bind`绑定时，该属性值不会从 Vue 实例中获取，只有绑定了才行
  - 注意指令和参数之间不能有空格，即 v-bind 与 title 之间不能有空格
  - **v-bind 指令若作用于布尔属性（例如 disabled）时，若属性值对应的 data 选项对象中的值为`null`,`undefined`,`false`时，该属性则不会包含在该元素上。**
  - **数据绑定：能够将数据绑定到 DOM 文本（模板插值）、attribute（指令带的属性比如 title）、DOM 结构（控制结构变化，比如`v-if`指令）**
- 条件：`v-if`指令：属性值 seen 来自 Vue 实例 data 中的 seen 属性
  - `v-if=seen`
- 循环：`v-for`指令：渲染列表
  - `v-for="todo in todos"`
  - 其中 todos 来自 Vue 实例 data 的属性
- 用户交互指令：`v-on`
  - `v-on:click="sendMsg"`
  - v-on 后带事件名，属性值为事件发生调用的方法
  - 属性值来自 Vue 实例 methods 的方法
  - 编写的方法只关注逻辑层面，不需要触碰 DOM（由 Vue 处理）
- 双向绑定：`v-model`：实现表单输入和应用状态之间双向绑定
  - `<input v-model="msg">`
  - 表示用户输入的内容会在相应的插值内容 msg 中变化
- `v-once`指令：执行一次性插值，即之后数据发生改变，插值内容不会发生变化，单指令，没有值
- `v-html`指令：
  - `v-html="rawHtml"`
  - 其中 rawHtml 为 data 选项对象的属性
  - 使用该属性，会将 rawHtml 属性值嵌入到该标签内部并渲染为 html
  - 不能使用 v-html 来复合局部模板，因为 Vue 不是基于字符串的模板引擎（是 render 函数？？），但 Vue 是基于 HTML 的模板语法，故而？？？

### 组件系统：一种抽象，允许使用小型、独立、可复用的组件构建大型应用。

- 组件树：界面的结构分解（比如页头，内容区，页脚）
- 组件模板：需要先注册一个组件才能使用该模板元素
  - 组件注册使用`Vue.component(component-name, {props:[],template:,...})`
  - 其中 props 中的值相当于一个自定义的元素属性
  - Vue 组件类似自定义元素（web 组件规范的一部分），vue 实现了它
    - web 组件规范未被所有浏览器实现，但 Vue 组件支持 IE9+以上版本
    - Vue 组件有元素自定义元素不具备的功能：跨组件数据流、自定义事件通信、构建工具集成

## Vue 实例

- Vue 未完全遵循 MVVM 模型
- **选项对象**：像 data，el 等等
  - data：当 vue 实例被创建时，才将 data 对象中的所有属性加入到 Vue 的响应式系统中，属性值发生改变，视图将会产生相应（更新）
    - 如果某些属性不确定是否会加在实例上面，可预先设定一些初始值
    - 而当给某变量使用了`Object.freeze()`会阻止修改该属性，即响应系统无法追踪该变化。
- Vue 应用的构造：new Vue 根实例、可选的嵌套的可复用的组件树
  - 所有的 Vue 组件都是 Vue 实例，且接受相同的选项对象，特有选项对象除外。
- Vue 实例的实例属性和方法
  - 都有前缀`$`，（例如`$el`即指 el 选项对象），便于区分用户属性

### 实例生命周期钩子

- 实例被创建有一系列初始化过程：像设置数据监听、编译模板、将实例挂载到 DOM、数据变化更新 DOM、运行生命周期钩子函数（可在不同阶段添加用户代码）
  - 例如`created`钩子（created 选项对象）表示在实例被创建之后执行的代码
  - 生命周期钩子的 this 指向调用它的 Vue 实例
  - 不要再选项属性或回调中使用箭头函数，因为箭头函数没有 this（会向上级作用域查找 this），经常导致一些错误

### 生命周期

八个生命周期函数及其使用场景：

- beforeCreate：拿不到任何数据
- created：**拿到 data 数据，但是 DOM 未挂载**（el 元素不可见），不能操作 DOM 元素
  - 使用：从服务器获取初始化数据，通过 Ajax 向服务器发送请求
- beforeMount
- mounted：el 选项被替换**挂载到实例**中，DOM 节点被创建
  - 操作 DOM 节点
- beforeUpdate
- updated
- beforeDestroy：实例销毁前被调用，移除整个实例
  - 移除定时器或事件绑定
- destroyed

图示：![生命周期图示](../../img/Vue-lifecycle.png)

## 模板语法

- Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定到底层 Vue 实例的数据
  - 所有的 Vue 模板都是合法的 html，能被遵循规范的浏览器和 HTML 解析器解析
  - 底层实现中，Vue 将模板编译成虚拟 DOM 渲染函数
  - 偏爱原生 JS，可不用模板，直接写渲染函数，使用可选的 JSX 语法

### 插值

- 文本插值：使用 Mustache `['mʌstæʃ]` 语法（双大括号）进行数据绑定
  - `{{ msg }}`
  - 若 msg 是 html 代码，会原样输出该代码，而不会渲染为 HTML 格式，输出 HTML 格式，需使用`v-html`指令
  - Mustache 语法不能作用于元素属性上，此时应使用`v-bind`指令
  - 动态渲染任意的 html 容易导致 XSS 攻击，只能对可信内容使用 HTML 插值，绝对不要使用用户提供的内容插值
- 对于所有的数据绑定，都支持 JS 表达式（会在所属实例中作为 JS 被解析），而不只只是简单的值，但不支持语句和块结构
  - 每个绑定只能包含一个 JS 表达式
  - 模板表达式不应该访问用户定义的全局变量，但可以访问系统全局变量（本来就有的）。

## 计算属性和侦听器

### 计算属性

- 模板内部表达式便利但设计初衷是用于简单运算，在其内部放入太多逻辑会让模板过重且难以维护。
- 对于任何复杂逻辑，应当使用计算属性
  - 像绑定普通属性一样在模板中绑定计算属性（语法相同）
  - 计算属性缓存 vs 方法
    - 在模板表达式中调用方法可以达到相同效果`{{ doSomething() }}`
    - 计算属性基于它们的**响应式依赖**进行缓存，只有在相关**响应式依赖改变才会重新求值**，即其依赖的实例中的某些属性改变它们才会改变，而未发生改变时会立即返回之前的计算结果，不用再次执行函数
    - **有缓存的意义**：避免过多的开销（自己理解的）
  - 计算属性 vs 侦听属性
    - 侦听属性：更通用的方式去观察和响应 Vue 实例上的数据变动
      - 不要滥用 watch
  - 计算属性的 setter
    - 默认只有 getter，需要时可以提供 setter（即 get/set 函数）
    - 当计算属性数据变动时，setter 会被调用，其相应的响应式依赖也会被更新

### 侦听器

- `watch`选项：更通用的响应数据变化的方法，当需要在数据变化时执行异步/开销较大的操作时，最有用
- 除了 watch 选项之外，可以使用命令式的`vm.$watch`api

### 计算属性 computed vs 侦听器 watch

> 参考：
> https://juejin.im/post/5b912c815188255c54428618

- computed：
  1. 支持缓存，依赖数据变化才重计算
  2. 不支持异步操作，含有 async 将无法监听数据变化
  3. 适用于一个属性是由其他属性计算而来的
  4. computed 的属性值是函数，这默认为该函数的返回值
- watch：
  1. 不支持缓存，数据变动（不管有没有变化），直接触发相应操作
  2. 支持异步操作
  3. 监听函数接收 2 个参数，`(new, old)`，
  4. 适用于一个监听数据（data，props）变化，需要执行的操作（比如其他数据发生变化，给后台发送数据等），没有返回值
  5. 监听数据若带有除函数外的属性，需要使用对象的形式，函数使用 handler，其他属性有：
     1. `immediate: true`：组件加载立即触发回调函数
     2. `deep: true`：监听对象属性/属性的属性的变化，会加大性能开销，可直接监听`obj.a`的形式减少开销

## Class 和 Style 绑定

- `v-bind`指令主要是类似于对元素的属性进行绑定，然后赋值给该属性
  - 将`v-bind`指令用于 class 和 style 时，Vue 做了专门的增强，表达式结果类型除了**字符串**，还可是**对象/数组**

### Class 绑定

- 使用**对象语法**：传给一个对象以动态切换 class
  - `v-bind:class="{ active: isActive }"`
    - 当 isActive 值为**真值**，则存在 active 这个 class
    - 真值：除 false、0、''、null、undefined、NaN 以外的值
    - 可传入多个 class 属性
    - 该指令可与普通 class 属性（指没有 v-bind 指令绑定的）共存，不会覆盖原有的 class
    - 绑定的数据对象不必内联到模板中，可以直接传入一个对象变量即可
      - 类似`{ active: isActive }` => `classObject`
      - 该对象变量可为一个 data 中的变量，也可是一个计算属性
- 使用**数组语法**：传入一个数组给`v-bind:class`
  - `v-bind:class="[activeClass, errorClass]"`
  - 即将数组元素变量的**属性值作为 class**
- 联合使用数组和对象语法：
  - `v-bind:class="[{ active: isActive }, errorClass]`
- 可以绑定自定义组件元素的 class，方法同上
  - 在自定义组件中使用 class 属性时，这些 class 被添加到该组件的根元素上，不会覆盖原有的 class

### 内联样式 style 绑定

- 使用对象语法：非常像 css
  - `v-bind:style="{ color: activeColor, fontSize: fontSize + 'px'}"`
  - CSS 属性名可使用驼峰式（camelCase）或短横线分隔（kebab-case，此需用引号括起）命名
  - 直接传入一个样式对象会让模板更清晰
    - `{...}` => `styleObject`
    - 对象可在 data 中或是一个计算属性
- 使用数组语法：将多个样式对象应用到同一个元素中
  - `v-bind:style="[baseStyles, overridingStyles]"`
  - 当需要添加浏览器引擎前缀的 CSS 属性时，Vue 会自动侦测并添加相应的前缀
  - 可以为 style 绑定的属性提供一个包含多个值的数组，常用于提供多个带前缀的值
    - `:style="{display: ['-webkit-box', '-ms-flexbox', 'flex'] }"`
    - 这样会渲染最后一个被浏览器支持的值

## 条件渲染

### `v-if`

- `v-if`指令用于条件性渲染一块内容，只会在指令表达式值为真时被渲染到 DOM 中，否则应用于该指令上的元素将不会存在于 html 的内容中
  - `v-if="awesome"`
  - 配合`v-else`使用添加一个 ese 块
    - `v-else`，无属性值，表`v-if`的 else 块
    - `v-else`指令所在元素必须紧跟在`v-if`或`v-else-if`指令元素的后面，否则不起作用
  - `v-else-if`：充当`v-if`的 else-if 块，可连续使用，类编程语言的用法
    - `v-else-if`指令所在元素必须紧跟在`v-if`或`v-else-if`指令元素后面
  - 在 template 元素中使用`v-if`渲染分组
    - 这样做不必新增额外的包裹元素，同时可以添加到 template 元素包含的所有子元素上（成组切换），此时 template 元素是不可见包裹元素（最终不包括 template 元素）
- 使用 key 管理可复用的元素
  - 因为 Vue 会尽可能高效的渲染元素，通常会复用已有元素而不是从头开始渲染（像已输入的内容不会清除）。
    - 好处：运行更快，可在不同登录方式切换等
    - 当两个模板元素包含的元素相同时，使用条件命令切换，不会清除用户已输入的内容，即元素不会被替换，只是替换掉了元素中的内容而已
  - 如果不想复用某些元素，可给这些元素分别加上不同的 key 属性即可，此时切换，加入 key 属性的元素将会重新渲染，但未添加 key 属性的元素仍会被复用
- 不推荐同时在一个元素中使用 v-if 和 v-for，当两者一起使用时，**v-for 优先级比 v-if 高**，这意味着若同时使用，v-if 将分别重复运行于每个 v-for 循环中，当想为部分项渲染节点时十分有用
  - 若目的是有条件的跳过循环的执行，可将 v-if 放在外层元素中（比如 template 等）

### `v-show`

- `v-show`指令也用于根据条件展示元素的选项，
  - `v-show="ok"`
  - 但带有 v-show 指令的元素**始终会被渲染**并保留在 DOM 中，它只是简单的**切换元素 css 属性 display**
  - v-show 不支持 template 元素，也不支持 v-else

### `v-if` vs `v-show`

- `v-if`是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当的被销毁和重建（dom节点的删除和重建）
  - 它是惰性的：若初始渲染条件为假，不做任何渲染，除非条件变为真
  - 更高的切换开销，运行时条件很少改变使用 v-if 较好
- `v-show`：不过初始条件如何，元素总被渲染，进行 display 的切换
  - 更高的初始渲染开销，频繁切换应使用 v-show 较好

## 列表渲染

### `v-for`

- 用`v-for`指令基于一个数组来渲染一个列表
  - 语法：`v-for="item in items"`
  - items 是源数据数组，item 是被迭代的数组元素别名
  - 在 v-for 块内，可以访问所有父作用域的属性（比如父元素的 data 选项数据，**\*【补】**：父元素/组件指的是自定义元素的名字，子元素/组件指的是自定义元素中的 template 模板\*）
  - v-for 支持一个可选的第二个参数，表示当前项的索引
    - `v-for="(item, index) in items"`
      - 这和遍历对象的语法类似，item 代表对象属性的值，index 代表对象属性的名
    - 可用 of 替代 in 作为分隔符，它更接近 JS **迭代器**语法
      - `v-for="item of items"`
  - 可以用 v-for 遍历一个对象的属性
    - 在遍历对象时，会按`Object.keys()的结果遍历，但不能保证其结果（顺序）在不同的 JS 引擎下一致
    - `v-for="value in object"`，其中 value 表示属性的值
    - 可提供第二个参数作为键名属性
      - `v-for="(value, name) in object"`
      - value 表示键值（属性值），name 表示键名（属性名）
    - 可提供第三个参数作为索引
      - `v-for="(value, name, index) in object`

### 就地更新和节点跟踪

- vue 更新使用 v-for 渲染的元素列表时，默认使用**就地更新**策略
  - _📌【**补**】：就地更新指的是元素节点没有发生移动变化，而是数据的重新渲染，即数据发生简单的移动，这样可能导致操作节点时发现不是目标操作节点，可用 key 解决该问题_
  - 如果数据项顺序被改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并确保每个索引位置正确渲染
  - 这个默认模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态（像表单输入值）的列表渲染输出
- 为了便于**跟踪每个节点**，从而重用和重排现有元素，需要为每项提供一个唯一 key 属性（该属性值值唯一即可）
  - 尽量使用 v-for 时提供 key 属性，除非遍历的 dom 十分简单，或想刻意依赖默认行为提升性能
  - key 属性是 Vue 识别节点的一个通用机制，并不仅与 v-for 关联
  - key 属性值应该使用基本类型值

#### 📌补 key的作用

1. 跟踪节点，实现重用/重排现有元素，移除key不存在的元素
2. 不使用key：就地复用，最大限度减少动态元素（减少重用/重排），再利用相同类型的元素


### 数组更新检测

- vue 将被侦听的数组变异方法进行了包裹，所以将会**触发视图更新**
  - 变异方法：push、pop、shift、unshift、splice、sort、reverse
  - 变异方法：指会改变调用这些方法的原始数组
    - 非变异方法：filter、concat、slice（不会改变原数组，而是返回一个新数组）
    - Vue 为了使 DOM 元素最大限度重用，不会导致使用了非变异方法丢弃现有 DOM 并重新渲染列表，用一个含相同元素的数组去替换原来数组是非常高效的操作
- 由于 JS 的限制，**Vue 不能检测以下数组的变动**：（即发生下列操作时 Vue 不会发生改动，这是指当页面载入之后再发生下列变化时，再次更改无效（事件点击更改，浏览器控制台更改），应使用替代方法，而在页面载入之前有效，比如写在代码中）
  - 当利用索引直接设置一个数组项时
    - `vm.items[indexOfItem] = newValue`
    - 解决方法：2 种，实现和上述一样效果，并在响应式系统内触发状态更新
      - 第一种：
        - `Vue.set(vm.items, indexOfItem, newValue)`使用`Vue.set`
      - 第二种：
        - `vm.items.splice(indexOfItem, 1, newValue)`使用`Array.prototype.splice`
      - 第三种：该方法是`Vue.set`的一个别名
        - `vm.$set(vm.items, indexOfItem, newValue)`
  - 当修改数组长度时
    - `vm.items.length = newLength`
    - 解决方法：使用 splice
      - `vm.items.splice(newLength)`

### 对象更新检测

- 由于 JS 限制，Vue 不能检测对象属性的添加和删除
  - 对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性，
  - 解决方法：
    - 使用`Vue.set(obj, propertyName, value)`添加响应式属性
    - 使用`vm.$set(obj, propertyName, value)`
    - 添加多个对象响应式属性，不能如下列所示：
      - `Object.assign(obj, {prop1: n1, prop2: n2 })`
      - 解决方法：即用两个对象的属性创建一个新的对象
        - 使用`obj = Object.assign({}, obj, {prop1: n1, prop2: n2 })`

### 其他

- 在显示一个数组经过排序/过滤的版本，但不改变/重置原始数据，可创建一个计算属性/函数返回过滤/排序后的版本（相当于不直接对原始数据进行操作，而定义一个新的变量/方法去操作原始数据一样）
- `v-for`中可以接受整数的遍历，即将模板重复对应次数
  - `v-for="n in 10"`
- 可以在 template 元素上使用 v-for 指令渲染包含多个元素的内容
- 可以在任何自定义组件中使用 v-for 指令
  - 在组件中使用 v-for 时，必需有 key 属性
  - 任何数据不会被自动传递到组件里，因组件有自己独立的作用域，为了把数据传入到组件，需要使用 props 属性
    - 数据注入到组件会使组件与指令的运作紧密耦合，不利于组件重复使用
    - 使用**is 属性**是十分必要的，因为在某些特殊元素中，只有相应的元素才会当作其内部有效内容，这样做与直接使用<custom-component>相同，但可以避免一些潜在的浏览器解析错误

## 事件处理

- 使用`v-on`指令监听 DOM 事件，并在触发时运行一些 JS 代码
  - 当事件处理逻辑变复杂时，直接在 v-on 中书写大量的 js 代码不可行，此时应接受一个需要调用的方法名称更好（绑定一个方法名）
  - 或在内联 JS 语句中调用方法，例如`v-on:click="say('hi')"`
  - 若想在内联语句中访问原始的 DOM 事件（比如事件对象），可以将**特殊变量\$event**传入内联语句中调用方法，例如`v-on:click="warn("msg", $event)"`，此时可以访问 event 事件对象了
  - ***监听多个方法*** 
    - `v-on="{click: onClick, focus: onFocus }`
    - 此种形式和`v-bind`绑定一个含多个props的对象类似




### 事件修饰符

- 事件修饰符在 v-on 指令中使用，由点开头的指令后缀
  - `.stop`：阻止事件继续传播
  - `.prevent`：阻止事件的默认操作
  - `.capture`：事件捕获，内部元素触发的事件先在该元素上处理，然后才交给内部元素处理
  - `.self`：只有 event.target 是当前元素自身时触发处理函数
  - `.once`：事件之后触发一次，其他修饰符只能作用于原生 DOM 事件，而`.once`还能作用到自定义的组件事件上
  - `.passive`：不想阻止事件的默认行为，默认行为（比如滚动事件的滚动行为）将会比调用的事件先触发，尤其能够提升移动端性能
    - 当.passive 和.prevent 一起使用时，.prevent 将会被忽略，并会有一个警告
- **事件修饰符可以串联，其他修饰符也可串联使用**
- 使用修饰符时，顺序很重要，相应的代码会以同样的顺序产生
  - 例如`v-on:click.prevent.self`会阻止所有点击事件，而`v-on:click.self.prevent`只会阻止该元素的点击事件（这应该看修饰符作用的位置，前一个作用在 click 上，而后一个作用在 self 上

#### sync修饰符

问题：真正的双向绑定会带来维护性的问题，因为子组件可以变更父组件，且这种变更无法捕捉

解决：推荐子组件以`update:myProperty`的模式触发事件

使用：
- 父组件：
  - `<parent :title="doc.title" @update:title="doc.title = $event">`
  - 简写：`<parent :title.sync="doc.title">`
  - 绑定一个对象：`<parent v-bind.sync="doc">`，此时doc内部的每个prop都将分发出去，*注意此时不能跟一个字面量对象，跟一个对象变量即可*
- 子组件：
  - `this.$emit("update:title", data)`

注意：
1. sync修饰符和bing一起使用（简写情形）时，不能跟表达式，只能是提供一个属性
2. 

### 按键修饰符

- Vue 允许为 v-on 在监听键盘事件时添加按键修饰符
  - 比如`.enter`，**可以将 KeyboardEvent.key 暴露的任意有效按键名转为短横线命名作为修饰符**
  - alt，arrow-right，page-down 等
- keyCode 事件用法已经废弃可能不会在新的浏览器支持
  - 同样可使用 keyCode 码作为按键修饰符，比如`v-on:keyup.13="submit"`
  - 为了在必要情况下支持旧浏览器，Vue 提供了绝大多数常用按键码的别名（按键修饰符），有些按键在 IE9 中有不同的 key 值，支持 IE9 应首先 Vue 内置的别名
  - **可通过全局`config.keyCodes`对象自定义按键修饰符别名？？？**
    - `Vue.config.keyCodes.f1 = 112`

### 系统修饰键

- 使用修饰符实现仅在按下相应按键时才触发鼠标或键盘事件的侦听器
  - `.ctrl`：
  - `.alt`：
  - `.shift`：
  - `.meta`：在 mac 系统 meta 代表 command 命令，在 Windows 系统代表 win 徽标键
  - 应注意每个修饰键的含义，比如 keyup 事件和 ctrl 修饰符使用时，表示事件触发时 ctrl 必须处于按下状态（即只有在按住该键并释放其他键才能触发 keyup.ctrl，而若想在释放 ctrl 时触发事件应该使用 keycode，替换为 keyup.17 即可
  - `.exact`：精确控制某些键触发事件，上面的修饰符是笼统的，只有满足条件即可，而这是严格满足条件（**只有这些修饰符操作时才能触发事件**：_📌【**补**】：只有这一个键按下/松开的时候，其他键不允许按住_ ）
  - 鼠标按钮修饰符：会限制处理函数仅响应特定的鼠标按钮
    - `.left`：
    - `.right`
    - `.middle`

### 为什么在 HTML 中监听事件

- 这种事件监听的方式违背了关注点分离的优良传统，但由于所有的 Vue 事件处理方法和表达式严格绑定在当前视图的 ViewModel 上，不会导致维护上的困难
- 使用 v-on 的好处：
  - 看 html 模板便能轻松定位在 JS 代码中相应的方法
  - 无需在 JS 中手动绑定事件，ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试
  - 当一个 ViewModel 被销毁时，所有事件处理器都会自动被删除，无需担心清理

## 表单输入绑定

### 基础用法

- `v-model`指令：用于在表单的`<input>`、`<textarea>`和`<select>`元素上创建双向数据绑定，它会根据控件类型自动选取正确的方法来更新元素
  - `v-model`本质上是语法糖
  - 负责监听用户的输入事件以更新数据
  - `v-model`会忽略所有表单元素的 value（针对 input 文本）、checked（针对单/多选）、selected（针对 select）属性的初始值（即会用 v-model 绑定的内容代替），而总是将 Vue 实例的数据作为数据来源，应通过 JS 在组件的 data 选项中声明初始值
    - 在文本区域 textarea 元素内部插值并不会生效，应用 v-model 代替
- `v-model`在内部为不同的输入元素使用不同的属性并抛出不同的事件
  - text 和 textarea 元素使用 value 属性和 input 事件
  - checkbox 和 radio 使用 checked 属性和 change 事件
  - select 字段将 value 作为 prop 并将 change 作为事件
    - 当 v-model 表达式初始值未能匹配任何选项，select 元素将渲染为未选中状态，而在 ios 中会使用户无法选择第一个选项（该情况不会触发 change 事件），故推荐提供第一个值为空的禁用选项（value 为空，并设置了 disabled 属性）
    - select 元素选中的是 option 元素的 value 值（有 value 值的情况下），为不是内部插入的文本值
    - 单选/复选按钮也是选中的 value 值
  - 对于需要使用输入法（中文、日语）等语言，v-model 不会在输入法组合文字过程中得到更新，若想使用这个效果，应使用 input 事件

### 值绑定

- 对于单选/复选按钮以及选中框，v-model 绑定的值通常为静态字符串（即指选中项 value 的值），而当复选框 v-model 绑定的变量是布尔值，则所有的元素同时变为 true/false
- 但若想把值绑定到 Vue 实例的一个动态属性上，可用 v-bind 实现，且该值可以不是字符串
  - 因为最终 v-model 绑定的变量值即等于 value 的值

### 修饰符

- `.lazy`：v-model 在每次 input 事件触发后将输入框的值与数据进行同步（除需用输入法组合的字），可添加 lazy 修饰符，从而转变为使用 change 事件进行同步（即在改变时更新，而非输入时更新，需要失去焦点或按住其他特殊按键才会更新）
- `.number`：若想自动将用户输入的值转为数值类型，可给 v-model 添加 number 修饰符，这是很有用的，因为即使在 type=number 时输入元素也总是返回字符串。
  - 若该值无法被 parseFloat()解析，则会返回原始的值
  - 失去焦点时才会发生变化
- `.trim`：若要自动过滤用户输入的首尾空白字符，可给 v-model 添加 trim 修饰符

- number 和 trim 修饰符都是在失去焦点时，其输入框中的内容会自动变化为相应状态

### 在组件上使用 v-model

- HTML 原生的输入元素类型并不总能满足需求，但 Vue 组件系统允许创建具有自定义行为且可复用的输入组件，这些组件可以与 v-model 一起使用

## 疑问

- 什么是渐进式框架
- 响应式
- 什么叫做逻辑层面
- MVVM 模型是什么
- Vue 的生命周期
- Vue 不是基于字符串的模板引擎，Vue 用的是什么模板语法呢？？
- XSS 攻击？？
- 什么叫重新渲染，什么叫渲染？？？重新加载还是（事实上重新渲染会将原有内容清空）
- 当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“**就地更新**”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染
- 什么叫视图更新？
